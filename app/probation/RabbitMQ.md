### RabbitMQ

#### Общие сведения

RabbitMQ ‒ программный брокер сообщений на основе стандарта AMQP ‒ связующее программное обеспечение, ориентированное на обработку сообщений.

Создан на основе системы Open Telecom Platform, написан на языке Erlang, в качестве движка базы данных для хранения сообщений использует Mnesia.

Состоит из сервера, библиотек поддержки протоколов (HTTP, XMPP и STOMP), клиентских библиотек AMQP для ряда языков и различных плагинов (например, для мониторинга и управления через HTTP или веб-интерфейс).

Поддерживает горизонтальное масштабирование.

#### Основные понятия

**Message** (сообщение) ‒ набор данных, передаваемых через RabbitMQ. Может быть представлено скалярным значением, либо сериализованной структурой данных. В RabbitMQ сообщения хранятся только в очередях.

**Producer** (поставщик/издатель) ‒ программа, отправляющая сообщения.

**Consumer** (потребитель/издатель) ‒ программа, принимающая сообщения.

**Queue** (очередь) ‒ очередь сообщений.

**Exchange** (точка обмена) - пункт распределения сообщений по очередям. Выполняет две функции: получает сообщения от поставщика и отправляет их в очереди. Бывают различных видов (для поддержки различных видов связей (bindings, привязок) с очередями).

Очереди существуют внутри RabbitMQ и не имеют ограничений на количество сообщений. Отправлять сообщения в одну очередь может любое количество поставщиков, а получать сообщения из одной очереди может любое количество подписчиков. С точки зрения персистентности могут быть обычными и устойчивыми, с точки зрения времени существования - постоянными и временными.

#### Особенности работы

##### Распределение сообщений

По умолчанию, RabbitMQ передаёт каждое новое сообщение следующему подписчику. Таким образом, все подписчики получат одинаковое количество сообщений.

##### Подтверждение сообщений

RabbitMQ поддерживает подтверждение сообщений. Подтверждение (ack, acknowledge) отправляется подписчиком для информирования RabbitMQ о том, что полученное сообщение было обработано и RabbitMQ может его удалить.

Если подписчик прекратил работу и не отправил подтверждение, RabbitMQ поймет, что сообщение не было обработано, и передаст его другому подписчику. В этом случае можно быть увереным, что ни одно сообщение не будет потеряно, даже если выполнение программы-обработчика неожиданно прекратится.

Для обработки сообщений отсутствует тайм-аут. RabbitMQ передаст их другому подписчику только если соединение с первым будет закрыто, поэтому нет никаких ограничений на время обработки сообщения.

По умолчанию используется ручное подтверждение сообщений. Можно принудительно включить автоматическое подтверждение сообщений, указав для очереди флаг _**no_ack=True**_.

##### Устойчивость сообщений

По умолчанию при остановке или падении сервера RabbitMQ все очереди и сообщения теряются, но это поведение можно изменить. Для того чтобы сообщения оставались в очереди после перезапуска сервера, необходимо сделать как очереди, так и сообщения устойчивыми.

Очередь можно объявить как устойчивую с помощью флага _**durable=true**_.

Пометка сообщения, как устойчивого, не дает гарантии, что сообщение не будет утеряно. Несмотря на то, что это заставляет RabbitMQ сохранять сообщение на диск, есть небольшой промежуток времени, когда RabbitMQ подтвердил принятие сообщения, но еще не записал его. Также RabbitMQ не делает fsync(2) для каждого сообщения, поэтому какие-то из них могут быть сохранены в кэш, но еще не записаны на диск. Гарантия устойчивости сообщений не полная, но её вполне достаточно в общем случае. Если требуется более высокая надежность, необходимо оборачивать операции в транзакции.

##### Равномерное распределение сообщений

По умолчанию RabbitMQ распределяет сообщения в тот момент, когда они попадают в очередь, не учитывая количество неподтвержденных сообщений у подписчиков, и просто отправляет каждое n-ое сообщение n-ому подписчику.

Чтобы равномерно распределять нагрузку по подписчикам, для подписчика следует указывать _**basic_qos**_ с опцией _**prefetch_count=1**_, это заставит RabbitMQ не отдавать подписчику единовременно более одного сообщения и подписчик не получит новое сообщение, до тех пор, пока не обработает и не подтвердит предыдущее. RabbitMQ передаст очередное сообщение первому освободившемуся подписчику.



